import { useState, useCallback, useEffect, useRef } from "react";

// â”€â”€â”€ PRE-RECORDED AI DEMO PAIRS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Generated by Claude using only the schema as context.
// No custom instructions, no examples, no tool definitions.
const DEMO_PAIRS = [
  {
    prompt: "Schedule a product launch announcement to Instagram and LinkedIn for next Tuesday at 2pm UTC",
    output: `mutation($input: CreatePostsInput!) {
  createPosts(input: $input) {
    success
    results {
      success
      post {
        id
        status
        scheduledAt
        profile {
          channel
          username
        }
      }
      error
    }
  }
}

# Variables:
# {
#   "input": {
#     "posts": [
#       {
#         "profileId": "prof_ig_001",
#         "text": "It's here! ðŸš€ We're thrilled to announce our new product. Link in bio for details. #launch #newproduct",
#         "scheduledAt": "2025-04-08T14:00:00Z"
#       },
#       {
#         "profileId": "prof_li_002",
#         "text": "I'm excited to share that we've officially launched our new product today. After months of development and feedback from our community, we built something that solves a real problem.",
#         "scheduledAt": "2025-04-08T14:00:00Z"
#       }
#     ]
#   }
# }`,
  },
  {
    prompt: "Show me my top 5 posts from last week ranked by engagement",
    output: `query {
  posts(
    status: SENT
    scheduledAfter: "2025-03-31"
    scheduledBefore: "2025-04-07"
    sortBy: ENGAGEMENT_DESC
    limit: 5
  ) {
    edges {
      node {
        id
        text
        sentAt
        profile {
          channel
          username
        }
        analytics {
          impressions
          likes
          comments
          shares
          clicks
        }
      }
    }
    totalCount
  }
}`,
  },
  {
    prompt: "Set up a webhook to notify me when posts fail or get comments",
    output: `mutation {
  createWebhook(input: {
    url: "https://myapp.com/webhooks/buffer"
    events: [POST_FAILED, COMMENT_RECEIVED]
  }) {
    success
    webhook {
      id
      url
      events
      enabled
      secret
      createdAt
    }
    error
  }
}`,
  },
  {
    prompt: "Get all my profiles and check which ones are disconnected",
    output: `query {
  profiles {
    id
    channel
    name
    username
    isConnected
    timezone
  }
}`,
  },
  {
    prompt: "Find all draft posts tagged with our Q1 campaign and add them to the queue",
    output: `# Step 1: Find all draft posts with the Q1 campaign tag
query {
  posts(status: DRAFT, tagId: "tag_q1_campaign") {
    edges {
      node {
        id
        text
        profile {
          channel
          username
        }
        tags {
          name
        }
      }
    }
    totalCount
  }
}

# Step 2: For each post ID returned, add it to the queue
mutation {
  addToQueue(id: "post_001") {
    success
    post {
      id
      status
      scheduledAt
    }
    error
  }
}`,
  },
  {
    prompt: "Check my rate limit then get analytics for all profiles this quarter",
    output: `# Step 1: Check rate limit budget before batch operation
query {
  rateLimit {
    limit
    remaining
    resetsAt
    windowSeconds
  }
}

# Step 2: Get quarterly analytics for all profiles
query {
  profiles {
    id
    channel
    username
    analytics(period: QUARTER) {
      followers
      followersChange
      postCount
      impressions
      totalEngagement
      engagementRate
      periodStart
      periodEnd
    }
  }
}`,
  },
  {
    prompt: "Reply to a customer comment thanking them for their feedback",
    output: `# Step 1: Get recent unreplied comments
query {
  comments(postId: "post_xyz789", limit: 10) {
    edges {
      node {
        id
        text
        authorName
        createdAt
        isReplied
      }
    }
    totalCount
  }
}

# Step 2: Reply to the specific comment
mutation {
  replyToComment(
    commentId: "comment_abc123"
    text: "Thank you so much for the kind words! We really appreciate your support. ðŸ’›"
  ) {
    success
    error
  }
}`,
  },
  {
    prompt: "Set my Instagram to post Monday/Wednesday/Friday at 9am and noon",
    output: `mutation {
  updateSchedule(input: {
    profileId: "prof_ig_001"
    schedules: [
      {
        days: ["monday", "wednesday", "friday"]
        times: ["09:00", "12:00"]
      }
    ]
  }) {
    success
    profile {
      channel
      username
      schedules {
        days
        times
      }
    }
    error
  }
}`,
  },
];

// â”€â”€â”€ DOCS CONTENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const DOCS = {
  quickstart: {
    title: "Quickstart",
    subtitle: "Zero to first API call in 5 minutes",
    sections: [
      {
        heading: "Install the SDK",
        body: "The Buffer SDK handles authentication, retries, and rate limiting. Install it and initialize with your access token.",
        code: `npm install @buffer/sdk`,
        lang: "bash",
      },
      {
        heading: "Hello, Buffer",
        body: "Three lines to verify your connection. This lists every social account linked to your Buffer workspace.",
        code: `import { Buffer } from "@buffer/sdk";

const buffer = new Buffer({ accessToken: process.env.BUFFER_TOKEN });
const profiles = await buffer.profiles.list();

console.log(profiles.map(p => \`\${p.channel}: @\${p.username}\`));
// â†’ ["instagram: @mybrand", "linkedin: @mybrand", "x: @mybrand"]`,
        lang: "javascript",
      },
      {
        heading: "Or Use the GraphQL API Directly",
        body: "Prefer raw GraphQL? Every SDK method maps 1:1 to the schema. Here's the same call in JavaScript, Python, and curl.",
        code: `const response = await fetch("https://api.buffer.com/graphql", {
  method: "POST",
  headers: {
    "Authorization": "Bearer YOUR_ACCESS_TOKEN",
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    query: \`{ profiles { id channel name username isConnected } }\`,
  }),
});

const { data } = await response.json();
console.log(data.profiles);`,
        lang: "javascript",
      },
      {
        heading: null,
        body: null,
        code: `import requests

response = requests.post(
    "https://api.buffer.com/graphql",
    headers={
        "Authorization": "Bearer YOUR_ACCESS_TOKEN",
        "Content-Type": "application/json",
    },
    json={"query": "{ profiles { id channel name username isConnected } }"},
)

profiles = response.json()["data"]["profiles"]
print(profiles)`,
        lang: "python",
      },
      {
        heading: null,
        body: null,
        code: `curl -X POST https://api.buffer.com/graphql \\
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{"query": "{ profiles { id channel name username isConnected } }"}'`,
        lang: "curl",
      },
      {
        heading: "Create & Schedule a Post",
        body: "Include scheduledAt to queue it. Omit it to save as a draft. Always check the success and error fields.",
        code: `const response = await fetch("https://api.buffer.com/graphql", {
  method: "POST",
  headers: {
    "Authorization": "Bearer YOUR_ACCESS_TOKEN",
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    query: \`mutation($input: CreatePostInput!) {
      createPost(input: $input) {
        success
        post { id status scheduledAt }
        error
      }
    }\`,
    variables: {
      input: {
        profileId: "prof_abc123",
        text: "Excited to share what we've been working on! ðŸš€",
        scheduledAt: "2025-04-01T14:30:00Z",
      },
    },
  }),
});

const { data } = await response.json();
console.log(data.createPost.post);`,
        lang: "javascript",
      },
      {
        heading: null,
        body: null,
        code: `response = requests.post(
    "https://api.buffer.com/graphql",
    headers={
        "Authorization": "Bearer YOUR_ACCESS_TOKEN",
        "Content-Type": "application/json",
    },
    json={
        "query": """mutation($input: CreatePostInput!) {
            createPost(input: $input) {
                success
                post { id status scheduledAt }
                error
            }
        }""",
        "variables": {
            "input": {
                "profileId": "prof_abc123",
                "text": "Excited to share what we've been working on! ðŸš€",
                "scheduledAt": "2025-04-01T14:30:00Z"
            }
        }
    },
)

print(response.json()["data"]["createPost"])`,
        lang: "python",
      },
      {
        heading: "Post to Multiple Channels",
        body: "Use createPosts (plural) to publish across platforms in one call. Customize the text for each channel's audience and character limits.",
        code: `const response = await fetch("https://api.buffer.com/graphql", {
  method: "POST",
  headers: {
    "Authorization": "Bearer YOUR_ACCESS_TOKEN",
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    query: \`mutation($input: CreatePostsInput!) {
      createPosts(input: $input) {
        success
        results {
          success
          post { id profile { channel } status }
          error
        }
      }
    }\`,
    variables: {
      input: {
        posts: [
          {
            profileId: "prof_ig_001",
            text: "New feature alert! ðŸŽ‰ Link in bio for details.",
            scheduledAt: "2025-04-01T14:30:00Z",
          },
          {
            profileId: "prof_li_002",
            text: "We just shipped a feature that changes how teams collaborate on content. Here's what it does and why it matters.",
            scheduledAt: "2025-04-01T14:30:00Z",
          },
        ],
      },
    },
  }),
});

const { data } = await response.json();
data.createPosts.results.forEach(r =>
  console.log(r.post.profile.channel, r.success)
);`,
        lang: "javascript",
      },
      {
        heading: "Set Up Webhooks",
        body: "Instead of polling (which ate the old API's 60 req/min budget), register a webhook and get notified in real time when posts publish, fail, or receive comments.",
        code: `const response = await fetch("https://api.buffer.com/graphql", {
  method: "POST",
  headers: {
    "Authorization": "Bearer YOUR_ACCESS_TOKEN",
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    query: \`mutation {
      createWebhook(input: {
        url: "https://myapp.com/webhooks/buffer"
        events: [POST_SENT, POST_FAILED, COMMENT_RECEIVED]
      }) {
        success
        webhook { id secret events }
        error
      }
    }\`,
  }),
});

const { data } = await response.json();
// Save the secret for verifying webhook signatures
console.log("Webhook secret:", data.createWebhook.webhook.secret);`,
        lang: "javascript",
      },
    ],
  },
  errors: {
    title: "Error Reference",
    subtitle: "Every error you'll encounter, with response bodies and fixes",
    sections: [
      {
        heading: "How Errors Work in GraphQL",
        body: "Unlike REST, GraphQL returns 200 OK for most responses. You'll see two kinds of errors: GraphQL-level (malformed query) in a top-level errors array, and application-level (operation failed) in the mutation's error field. Always check both.",
        code: `const result = await response.json();

// GraphQL-level errors
if (result.errors) {
  console.error("Query error:", result.errors[0].message);
  return;
}

// Application-level errors
if (!result.data.createPost.success) {
  console.error("Failed:", result.data.createPost.error);
  return;
}`,
        lang: "javascript",
      },
      {
        heading: "Text Exceeds Character Limit",
        body: "Each channel has a different limit. The error tells you exactly how long your text is and what the limit is. Validate client-side using the Channel enum descriptions.",
        code: `{
  "data": {
    "createPost": {
      "success": false,
      "post": null,
      "error": "Text exceeds maximum length for X (280 characters). Your text is 314 characters."
    }
  }
}`,
        lang: "json",
      },
      {
        heading: "Profile Disconnected",
        body: "The social media token expired or was revoked. Check profile.isConnected before posting. Subscribe to the PROFILE_CONNECTION_CHANGED webhook to detect this proactively.",
        code: `{
  "data": {
    "createPost": {
      "success": false,
      "post": null,
      "error": "Profile prof_abc123 is disconnected. The user must reauthorize this profile in Buffer."
    }
  }
}`,
        lang: "json",
      },
      {
        heading: "Rate Limited (429)",
        body: "Read X-RateLimit-Remaining on every response and throttle before you hit zero. The Retry-After header tells you when to resume. Use webhooks instead of polling.",
        code: `HTTP/1.1 429 Too Many Requests
X-RateLimit-Limit: 300
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 2025-04-01T14:35:00Z
Retry-After: 47

{
  "error": "rate_limit_exceeded",
  "message": "Rate limit exceeded. Try again in 47 seconds."
}`,
        lang: "http",
      },
      {
        heading: "Duplicate Content",
        body: "Social platforms penalize duplicate posts. Buffer prevents them at the API level within a 24-hour window.",
        code: `{
  "data": {
    "createPost": {
      "success": false,
      "post": null,
      "error": "This content was recently posted to this profile. Duplicate posts within 24 hours are not allowed."
    }
  }
}`,
        lang: "json",
      },
    ],
  },
  workflows: {
    title: "Common Workflows",
    subtitle: "Integration patterns for the most frequent use cases",
    sections: [
      {
        heading: "Content Calendar: Schedule a Week",
        body: "Get your profiles and their schedules, batch-create posts matched to time slots, then verify the queue. A typical three-step pattern for small businesses.",
        code: `# Step 1: Get profiles & schedules
query { profiles { id channel schedules { days times } } }

# Step 2: Batch create posts
mutation {
  createPosts(input: { posts: [
    { profileId: "prof_ig_123"
      text: "Monday motivation ðŸŒ± #smallbusiness"
      scheduledAt: "2025-04-07T09:00:00Z"
      tagIds: ["tag_motivation"] }
    { profileId: "prof_ig_123"
      text: "Behind the scenes âœ¨ #bts"
      scheduledAt: "2025-04-09T09:00:00Z" }
  ]}) { success results { success post { id } error } }
}

# Step 3: Verify queue
query {
  posts(status: QUEUED, scheduledAfter: "2025-04-07"
        scheduledBefore: "2025-04-13"
        sortBy: SCHEDULED_AT_ASC) {
    edges { node { text scheduledAt profile { channel } } }
    totalCount
  }
}`,
        lang: "graphql",
      },
      {
        heading: "Analytics Dashboard",
        body: "Pull profile-level metrics and top-performing posts. Compare engagement rates across channels to see where your audience is most active.",
        code: `# Profile-level metrics
query {
  profiles {
    channel username
    analytics(period: WEEK) {
      followers followersChange
      impressions totalEngagement engagementRate
    }
  }
}

# Top posts by engagement
query {
  posts(status: SENT, sortBy: ENGAGEMENT_DESC, limit: 5) {
    edges { node {
      text
      profile { channel }
      analytics { impressions likes comments shares clicks }
    }}
  }
}`,
        lang: "graphql",
      },
      {
        heading: "RSS-to-Buffer Pipeline",
        body: "Monitor a blog feed, generate platform-appropriate text, create drafts via the API. A human reviews and approves in Buffer's UI. Omit scheduledAt to keep posts as drafts.",
        code: `mutation {
  createPosts(input: { posts: [
    { profileId: "prof_x_456"
      text: "New on the blog: Content Calendar Guide â†’ myblog.com/cal" }
    { profileId: "prof_li_789"
      text: "Just published a guide on content calendars for small businesses.\\n\\nCovers the 3 biggest mistakes and how to avoid them.\\n\\nRead: myblog.com/cal" }
  ]}) {
    success
    results { success post { id status } error }
  }
}
# Both created as DRAFT (no scheduledAt)`,
        lang: "graphql",
      },
    ],
  },
  design: {
    title: "AI-Native Design",
    subtitle: "How the schema serves humans and AI agents from one source of truth",
    sections: [
      {
        heading: "The Problem",
        body: "APIs now serve two audiences: human developers reading docs, and AI agents parsing specs to construct requests. Most providers design for humans first, then bolt on AI support through separate spec files or thick adapter layers. This kit takes a different approach: design for both audiences from the start.",
      },
      {
        heading: "Why GraphQL Is Naturally AI-Friendly",
        body: "Self-describing schema via introspection. Strong typing eliminates ambiguity. Enums declare valid values (no hallucinated strings). Descriptions serve docs, IDEs, and AI agents simultaneously. Explicit nullability (!) marks what's required.",
      },
      {
        heading: "Schema Annotations That Do the Work",
        body: "Every description is a complete sentence understandable without context. Enum values include platform constraints ('X â€” up to 280 characters'). Arguments document format, defaults, and behavioral consequences inline. Mutations describe preconditions and side effects.",
        code: `# Good: AI agent knows the character limit
"X (formerly Twitter) â€” text posts up to 280 characters"
X

# Good: AI agent knows the behavioral consequence
"""
When to publish. ISO 8601 datetime.
If provided â†’ QUEUED. If omitted â†’ DRAFT.
The time must be in the future.
"""
scheduledAt: DateTime`,
        lang: "graphql",
      },
      {
        heading: "The Thin Bridge Pattern",
        body: "The MCP server reads the schema via introspection. Each query becomes a read tool, each mutation a write tool. Names, descriptions, and parameters come directly from the schema. No manual mapping. When the schema evolves, tools update automatically. If an AI struggles with a tool, the fix belongs in the schema description, not the bridge layer.",
      },
      {
        heading: "Try It Live",
        body: "The 'AI Preview' tab on this site demonstrates this in practice. Claude is given only the raw schema â€” no custom instructions, no examples, no tool definitions. Type a task in plain English and watch it generate the correct GraphQL. The schema descriptions alone are sufficient.",
      },
    ],
  },
};

// â”€â”€â”€ OLD VS NEW COMPARISON DATA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const COMPARISON = [
  { area: "Language examples", old: "Raw HTTP only, URL-encoded POST data", new: "JavaScript, Python, curl, and GraphQL" },
  { area: "Error documentation", old: "Bare table on separate page. No response bodies.", new: "Contextual errors inline, grouped by operation, with fixes" },
  { area: "Workflow guidance", old: "Isolated endpoints, no sequencing", new: "Multi-step patterns (content calendar, analytics, RSS pipeline)" },
  { area: "Media handling", old: "Confusing media[] associative array, 'not all fields required'", new: "Two-step upload â†’ attach pattern with clear size/format limits" },
  { area: "Rate limit info", old: "60 req/min, 429 with no context", new: "X-RateLimit-* headers on every response + queryable rateLimit field" },
  { area: "Event notifications", old: "Polling only (eats rate limit budget)", new: "Webhooks with signed payloads and typed events" },
  { area: "Comment management", old: "Not available via API", new: "Query comments, reply through API" },
  { area: "AI/agent support", old: "Not considered", new: "Schema annotations designed for LLM consumption + thin MCP bridge" },
  { area: "Character limits", old: "Stale (Twitter 140), required separate /info call", new: "Embedded in Channel enum descriptions, always current" },
];

// â”€â”€â”€ MCP TOOLS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const MCP_TOOLS = [
  { name: "query_profile", desc: "Get a single profile by ID", type: "read" },
  { name: "query_profiles", desc: "List all connected profiles", type: "read" },
  { name: "query_post", desc: "Get a single post by ID", type: "read" },
  { name: "query_posts", desc: "List posts with filters", type: "read" },
  { name: "query_tags", desc: "List all tags", type: "read" },
  { name: "query_webhooks", desc: "List webhook subscriptions", type: "read" },
  { name: "query_comments", desc: "Get comments on a post", type: "read" },
  { name: "query_rateLimit", desc: "Check rate limit budget", type: "read" },
  { name: "mutation_createPost", desc: "Create a post for one profile", type: "write" },
  { name: "mutation_createPosts", desc: "Batch create across profiles", type: "write" },
  { name: "mutation_updatePost", desc: "Edit a draft or queued post", type: "write" },
  { name: "mutation_deletePost", desc: "Permanently delete a post", type: "write" },
  { name: "mutation_unqueuePost", desc: "Revert queued post to draft", type: "write" },
  { name: "mutation_publishNow", desc: "Publish immediately", type: "write" },
  { name: "mutation_addToQueue", desc: "Add draft to queue", type: "write" },
  { name: "mutation_updateSchedule", desc: "Set auto-publish schedule", type: "write" },
  { name: "mutation_createTag", desc: "Create a new tag", type: "write" },
  { name: "mutation_tagPost", desc: "Tag a post", type: "write" },
  { name: "mutation_untagPost", desc: "Remove tag from post", type: "write" },
  { name: "mutation_uploadMedia", desc: "Upload image or video", type: "write" },
  { name: "mutation_createWebhook", desc: "Register a webhook", type: "write" },
  { name: "mutation_deleteWebhook", desc: "Remove a webhook", type: "write" },
  { name: "mutation_replyToComment", desc: "Reply to a comment", type: "write" },
];

// â”€â”€â”€ STYLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const colors = {
  bg: "#f4f5f7",
  surface: "#ffffff",
  surfaceHover: "#eef0f3",
  border: "#d8dce3",
  borderAccent: "#c4c9d4",
  text: "#1a1f2e",
  textMuted: "#4a5168",
  textDim: "#8890a4",
  accent: "#2563eb",
  accentSoft: "#2563eb14",
  green: "#16a34a",
  greenSoft: "#16a34a14",
  amber: "#ca8a04",
  amberSoft: "#ca8a0414",
  red: "#dc2626",
  redSoft: "#dc262614",
  cyan: "#0284c7",
  cyanSoft: "#0284c714",
};

// â”€â”€â”€ COMPONENTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function CodeBlock({ code, lang }) {
  const [copied, setCopied] = useState(false);
  const handleCopy = () => {
    navigator.clipboard.writeText(code);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };
  return (
    <div style={{ position: "relative", marginTop: 12, marginBottom: 16 }}>
      <div style={{
        background: "#1e2130",
        border: `1px solid ${colors.border}`,
        borderRadius: 8,
      }}>
        <div style={{
          display: "flex", justifyContent: "space-between", alignItems: "center",
          padding: "6px 12px", background: "#252a3a", borderBottom: `1px solid ${colors.border}`,
        }}>
          <span style={{ fontSize: 11, color: "#6b7280", fontFamily: "monospace", textTransform: "uppercase", letterSpacing: 1 }}>{lang}</span>
          <button onClick={handleCopy} style={{
            background: "none", border: "none", color: "#8890a4", cursor: "pointer", fontSize: 11,
            padding: "2px 8px", borderRadius: 4, transition: "color 0.2s",
          }}>
            {copied ? "âœ“ Copied" : "Copy"}
          </button>
        </div>
        <pre style={{
          padding: 16, margin: 0, overflow: "auto", fontSize: 13, lineHeight: 1.6,
          color: "#c4cbd8", fontFamily: "'JetBrains Mono', 'Fira Code', monospace",
          maxHeight: 400,
        }}>
          <code>{code}</code>
        </pre>
      </div>
    </div>
  );
}

function NavItem({ label, active, onClick, icon }) {
  return (
    <button onClick={onClick} style={{
      display: "flex", alignItems: "center", gap: 8,
      padding: "8px 14px", borderRadius: 6, border: "none", cursor: "pointer",
      background: active ? colors.accentSoft : "transparent",
      color: active ? colors.accent : colors.textMuted,
      fontSize: 13, fontWeight: active ? 600 : 400, fontFamily: "inherit",
      transition: "all 0.2s", width: "100%", textAlign: "left",
    }}>
      <span style={{ fontSize: 15 }}>{icon}</span>
      {label}
    </button>
  );
}

function Badge({ children, color = colors.accent, bg = colors.accentSoft }) {
  return (
    <span style={{
      display: "inline-block", padding: "2px 8px", borderRadius: 4,
      fontSize: 11, fontWeight: 600, color, background: bg,
      fontFamily: "monospace", letterSpacing: 0.5,
    }}>
      {children}
    </span>
  );
}

// â”€â”€â”€ PAGES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function LandingPage({ onNavigate }) {
  return (
    <div style={{ maxWidth: 800, margin: "0 auto", padding: "60px 20px" }}>
      <div style={{ marginBottom: 48 }}>
        <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 16 }}>
          <div style={{
            width: 36, height: 36, borderRadius: 8, background: colors.accent,
            display: "flex", alignItems: "center", justifyContent: "center", fontSize: 18, fontWeight: 700, color: "#fff",
          }}>B</div>
          <span style={{ fontSize: 13, color: colors.textDim, fontFamily: "monospace", letterSpacing: 1, textTransform: "uppercase" }}>
            Developer Experience Kit
          </span>
        </div>
        <h1 style={{
          fontSize: 40, fontWeight: 700, lineHeight: 1.15, color: colors.text, margin: "0 0 20px",
          fontFamily: "'DM Serif Display', Georgia, serif",
        }}>
          What Buffer's new API<br />developer experience<br />could look like.
        </h1>
        <p style={{ fontSize: 17, lineHeight: 1.7, color: colors.textMuted, maxWidth: 600, margin: "0 0 32px" }}>
          A proof of concept exploring how to build developer documentation that works for
          humans reading docs, AI agents parsing schemas, and everyone in between. Inspired
          by Buffer's API rebuild and designed to show what modern developer experience could look like.
        </p>
        <div style={{ display: "flex", gap: 12, flexWrap: "wrap" }}>
          <button onClick={() => onNavigate("ai")} style={{
            padding: "12px 24px", borderRadius: 8, border: "none", cursor: "pointer",
            background: colors.accent, color: "#fff", fontSize: 14, fontWeight: 600, fontFamily: "inherit",
          }}>
            AI Preview â†’
          </button>
          <button onClick={() => onNavigate("quickstart")} style={{
            padding: "12px 24px", borderRadius: 8, border: `1px solid ${colors.border}`, cursor: "pointer",
            background: "transparent", color: colors.text, fontSize: 14, fontWeight: 500, fontFamily: "inherit",
          }}>
            Read the Docs
          </button>
        </div>
      </div>

      <div style={{
        border: `1px solid ${colors.border}`, borderRadius: 12, padding: 32, marginBottom: 48,
        background: colors.surface,
      }}>
        <h2 style={{ fontSize: 18, fontWeight: 600, color: colors.text, margin: "0 0 8px" }}>
          What was missing from the old API docs?
        </h2>
        <p style={{ fontSize: 14, color: colors.textMuted, margin: "0 0 24px" }}>
          A side-by-side comparison based on analysis of Buffer's original developer documentation.
        </p>
        <div style={{ display: "flex", flexDirection: "column", gap: 2 }}>
          <div style={{ display: "grid", gridTemplateColumns: "180px 1fr 1fr", gap: 1, fontSize: 11, fontWeight: 600, color: colors.textDim, textTransform: "uppercase", letterSpacing: 1, padding: "0 12px 8px" }}>
            <span>Area</span><span>Old API</span><span>This Kit</span>
          </div>
          {COMPARISON.map((row, i) => (
            <div key={i} style={{
              display: "grid", gridTemplateColumns: "180px 1fr 1fr", gap: 1,
              padding: "10px 12px", borderRadius: 6,
              background: i % 2 === 0 ? "transparent" : "#ffffff04",
              fontSize: 13,
            }}>
              <span style={{ color: colors.text, fontWeight: 500 }}>{row.area}</span>
              <span style={{ color: colors.red, fontSize: 12 }}>{row.old}</span>
              <span style={{ color: colors.green, fontSize: 12 }}>{row.new}</span>
            </div>
          ))}
        </div>
      </div>

      <div style={{
        border: `1px solid ${colors.border}`, borderRadius: 12, padding: 32,
        background: colors.surface, marginBottom: 48,
      }}>
        <h2 style={{ fontSize: 18, fontWeight: 600, color: colors.text, margin: "0 0 8px" }}>What's in the kit</h2>
        <p style={{ fontSize: 14, color: colors.textMuted, margin: "0 0 24px" }}>
          Everything a Developer Advocate would build for an API launch.
        </p>
        <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 16 }}>
          {[
            { icon: "ðŸ“", title: "Annotated GraphQL Schema", desc: "1,100+ lines with descriptions designed for both human and AI consumption", link: "reference" },
            { icon: "ðŸš€", title: "Quickstart Guide", desc: "JavaScript, Python, and curl examples. Zero to first call in 5 minutes.", link: "quickstart" },
            { icon: "âš ï¸", title: "Error Reference", desc: "Every error with response bodies, explanations, and fixes. Not just a code table.", link: "errors" },
            { icon: "ðŸ”„", title: "Workflow Patterns", desc: "Content calendars, analytics dashboards, RSS pipelines, cross-channel publishing.", link: "workflows" },
            { icon: "ðŸ¤–", title: "AI-Native Design Doc", desc: "Why well-annotated schemas replace thick adapter layers for AI agents.", link: "design" },
            { icon: "ðŸ”Œ", title: "Thin-Bridge MCP Server", desc: "~250 lines. Schema introspection â†’ MCP tools. No manual mapping.", link: "mcp" },
          ].map((item, i) => (
            <div key={i} onClick={() => onNavigate(item.link)} style={{
              padding: 16, borderRadius: 8, border: `1px solid ${colors.border}`,
              cursor: "pointer", transition: "all 0.2s",
            }}
            onMouseEnter={e => { e.currentTarget.style.borderColor = colors.accent; e.currentTarget.style.background = colors.surfaceHover; }}
            onMouseLeave={e => { e.currentTarget.style.borderColor = colors.border; e.currentTarget.style.background = "transparent"; }}
            >
              <div style={{ fontSize: 20, marginBottom: 8 }}>{item.icon}</div>
              <h3 style={{ fontSize: 14, fontWeight: 600, color: colors.text, margin: "0 0 6px" }}>{item.title}</h3>
              <p style={{ fontSize: 12, color: colors.textMuted, margin: 0, lineHeight: 1.5 }}>{item.desc}</p>
            </div>
          ))}
        </div>
      </div>

      <div style={{ textAlign: "center", padding: "20px 0", borderTop: `1px solid ${colors.border}` }}>
        <p style={{ fontSize: 13, color: colors.textDim, margin: 0 }}>
          Built by <a href="https://grzeti.ch" style={{ color: colors.accent, textDecoration: "none" }}>Ed Grzetich</a> as a proof of concept
          for the <a href="https://buffer.com/developer-api" style={{ color: colors.accent, textDecoration: "none" }}>Buffer Developer API</a> rebuild.
        </p>
      </div>
    </div>
  );
}

function DocsPage({ docKey }) {
  const doc = DOCS[docKey];
  if (!doc) return null;
  return (
    <div style={{ maxWidth: 760, margin: "0 auto", padding: "40px 20px" }}>
      <h1 style={{ fontSize: 32, fontWeight: 700, color: colors.text, margin: "0 0 8px", fontFamily: "'DM Serif Display', Georgia, serif" }}>
        {doc.title}
      </h1>
      <p style={{ fontSize: 15, color: colors.textMuted, margin: "0 0 40px" }}>{doc.subtitle}</p>
      {doc.sections.map((section, i) => (
        <div key={i} style={{ marginBottom: section.heading ? 40 : 16 }}>
          {section.heading && (
            <h2 style={{ fontSize: 20, fontWeight: 600, color: colors.text, margin: "0 0 10px" }}>
              {section.heading}
            </h2>
          )}
          {section.body && (
            <p style={{ fontSize: 14, color: colors.textMuted, lineHeight: 1.7, margin: "0 0 4px" }}>
              {section.body}
            </p>
          )}
          {section.code && <CodeBlock code={section.code} lang={section.lang || "graphql"} />}
        </div>
      ))}
    </div>
  );
}

// â”€â”€â”€ SCHEMA REFERENCE DATA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SCHEMA_TYPES = {
  queries: [
    { name: "profile(id: ID!)", returns: "Profile", desc: "Get a single profile by its unique identifier" },
    { name: "profiles(channel: Channel)", returns: "[Profile!]!", desc: "List all connected social media profiles" },
    { name: "post(id: ID!)", returns: "Post", desc: "Get a single post by its unique identifier" },
    { name: "posts(...filters)", returns: "PostConnection!", desc: "Search and filter posts across all profiles" },
    { name: "tags", returns: "[Tag!]!", desc: "List all tags for organizing posts" },
    { name: "webhooks", returns: "[Webhook!]!", desc: "List all registered webhook subscriptions" },
    { name: "comments(postId: ID!)", returns: "CommentConnection!", desc: "Get comments on a published post" },
    { name: "rateLimit", returns: "RateLimitInfo!", desc: "Get current rate limit status" },
  ],
  mutations: [
    { name: "createPost(input)", desc: "Create a post for one profile. Omit scheduledAt â†’ DRAFT, include it â†’ QUEUED." },
    { name: "createPosts(input)", desc: "Batch create across multiple profiles in one call." },
    { name: "updatePost(input)", desc: "Edit a DRAFT or QUEUED post. SENT posts cannot be modified." },
    { name: "deletePost(id)", desc: "Permanently delete a DRAFT or QUEUED post." },
    { name: "unqueuePost(id)", desc: "Revert a queued post back to draft status." },
    { name: "publishNow(id)", desc: "Publish a draft or queued post immediately." },
    { name: "addToQueue(id)", desc: "Add a draft post to the next available queue slot." },
    { name: "updateSchedule(input)", desc: "Set the weekly auto-publish schedule for a profile." },
    { name: "createTag(input)", desc: "Create a new tag for organizing posts." },
    { name: "tagPost(postId, tagId)", desc: "Add a tag to a post." },
    { name: "untagPost(postId, tagId)", desc: "Remove a tag from a post." },
    { name: "uploadMedia(file, altText)", desc: "Upload an image or video for later attachment to posts." },
    { name: "createWebhook(input)", desc: "Register a webhook for real-time event notifications." },
    { name: "deleteWebhook(id)", desc: "Delete a webhook subscription." },
    { name: "replyToComment(commentId, text)", desc: "Reply to a comment on a published post." },
  ],
  types: [
    { name: "Profile", fields: "id, channel, name, username, avatarUrl, timezone, isConnected, schedules, posts, analytics" },
    { name: "Post", fields: "id, text, status, profile, media, scheduledAt, sentAt, createdAt, updatedAt, tags, error, analytics" },
    { name: "Media", fields: "id, type, url, thumbnailUrl, altText, width, height" },
    { name: "Schedule", fields: "id, days, times" },
    { name: "Tag", fields: "id, name, color" },
    { name: "Webhook", fields: "id, url, events, enabled, secret, createdAt" },
    { name: "Comment", fields: "id, text, authorName, authorAvatarUrl, createdAt, isReplied, post" },
    { name: "PostAnalytics", fields: "impressions, likes, comments, shares, clicks" },
    { name: "ProfileAnalytics", fields: "followers, followersChange, postCount, impressions, totalEngagement, engagementRate" },
    { name: "RateLimitInfo", fields: "limit, remaining, resetsAt, windowSeconds" },
  ],
  enums: [
    { name: "Channel", values: "INSTAGRAM, FACEBOOK, LINKEDIN, X, BLUESKY, THREADS, TIKTOK, PINTEREST, YOUTUBE, MASTODON, GOOGLE_BUSINESS_PROFILE" },
    { name: "PostStatus", values: "DRAFT, QUEUED, SENT, FAILED" },
    { name: "MediaType", values: "IMAGE, VIDEO, LINK, DOCUMENT" },
    { name: "AnalyticsPeriod", values: "WEEK, MONTH, QUARTER, YEAR, CUSTOM" },
    { name: "PostSortOrder", values: "SCHEDULED_AT_DESC, SCHEDULED_AT_ASC, CREATED_AT_DESC, ENGAGEMENT_DESC" },
    { name: "WebhookEvent", values: "POST_SENT, POST_FAILED, COMMENT_RECEIVED, PROFILE_CONNECTION_CHANGED, POST_UPDATED" },
  ],
};

function APIReferencePage() {
  const [section, setSection] = useState("reads");
  return (
    <div style={{ maxWidth: 760, margin: "0 auto", padding: "40px 20px" }}>
      <h1 style={{ fontSize: 32, fontWeight: 700, color: colors.text, margin: "0 0 8px", fontFamily: "'DM Serif Display', Georgia, serif" }}>
        API Reference
      </h1>
      <p style={{ fontSize: 15, color: colors.textMuted, margin: "0 0 24px" }}>
        {SCHEMA_TYPES.queries.length} queries, {SCHEMA_TYPES.mutations.length} mutations, {SCHEMA_TYPES.types.length} types, {SCHEMA_TYPES.enums.length} enums.
      </p>
      <div style={{ display: "flex", gap: 8, marginBottom: 24 }}>
        {[
          { key: "reads", label: "Read Operations" },
          { key: "writes", label: "Write Operations" },
          { key: "types", label: "Types" },
          { key: "enums", label: "Enums" },
        ].map(t => (
          <button key={t.key} onClick={() => setSection(t.key)} style={{
            padding: "6px 16px", borderRadius: 6, border: `1px solid ${section === t.key ? colors.accent : colors.border}`,
            background: section === t.key ? colors.accentSoft : "transparent",
            color: section === t.key ? colors.accent : colors.textMuted,
            cursor: "pointer", fontSize: 13, fontFamily: "inherit", fontWeight: 500,
            
          }}>
            {t.label}
          </button>
        ))}
      </div>

      {section === "reads" && (
        <div style={{ display: "flex", flexDirection: "column", gap: 4 }}>
          {SCHEMA_TYPES.queries.map(q => (
            <div key={q.name} style={{
              padding: "12px 14px", borderRadius: 6, border: `1px solid ${colors.border}`, background: colors.surface,
            }}>
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "baseline", marginBottom: 4 }}>
                <code style={{ fontSize: 13, color: colors.accent }}>{q.name}</code>
                <code style={{ fontSize: 11, color: colors.cyan }}>{q.returns}</code>
              </div>
              <p style={{ fontSize: 12, color: colors.textMuted, margin: 0 }}>{q.desc}</p>
            </div>
          ))}
        </div>
      )}

      {section === "writes" && (
        <div style={{ display: "flex", flexDirection: "column", gap: 4 }}>
          {SCHEMA_TYPES.mutations.map(m => (
            <div key={m.name} style={{
              padding: "12px 14px", borderRadius: 6, border: `1px solid ${colors.border}`, background: colors.surface,
            }}>
              <code style={{ fontSize: 13, color: colors.amber, display: "block", marginBottom: 4 }}>{m.name}</code>
              <p style={{ fontSize: 12, color: colors.textMuted, margin: 0 }}>{m.desc}</p>
            </div>
          ))}
        </div>
      )}

      {section === "types" && (
        <div style={{ display: "flex", flexDirection: "column", gap: 4 }}>
          {SCHEMA_TYPES.types.map(t => (
            <div key={t.name} style={{
              padding: "12px 14px", borderRadius: 6, border: `1px solid ${colors.border}`, background: colors.surface,
            }}>
              <code style={{ fontSize: 14, color: colors.text, fontWeight: 600, display: "block", marginBottom: 4 }}>{t.name}</code>
              <p style={{ fontSize: 12, color: colors.textMuted, margin: 0, fontFamily: "'JetBrains Mono', 'Fira Code', monospace" }}>{t.fields}</p>
            </div>
          ))}
        </div>
      )}

      {section === "enums" && (
        <div style={{ display: "flex", flexDirection: "column", gap: 4 }}>
          {SCHEMA_TYPES.enums.map(e => (
            <div key={e.name} style={{
              padding: "12px 14px", borderRadius: 6, border: `1px solid ${colors.border}`, background: colors.surface,
            }}>
              <code style={{ fontSize: 14, color: colors.text, fontWeight: 600, display: "block", marginBottom: 4 }}>{e.name}</code>
              <p style={{ fontSize: 12, color: colors.textMuted, margin: 0, fontFamily: "'JetBrains Mono', 'Fira Code', monospace" }}>{e.values}</p>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

function MCPServerPage() {
  const reads = MCP_TOOLS.filter(t => t.type === "read");
  const writes = MCP_TOOLS.filter(t => t.type === "write");
  return (
    <div style={{ maxWidth: 760, margin: "0 auto", padding: "40px 20px" }}>
      <h1 style={{ fontSize: 32, fontWeight: 700, color: colors.text, margin: "0 0 8px", fontFamily: "'DM Serif Display', Georgia, serif" }}>
        MCP Server
      </h1>
      <p style={{ fontSize: 15, color: colors.textMuted, margin: "0 0 8px" }}>
        A well-annotated GraphQL schema can be rapidly integrated into an MCP server, giving AI agents direct access to the API without manual tool definitions.
      </p>
      <p style={{ fontSize: 13, color: colors.textDim, margin: "0 0 32px" }}>
        {MCP_TOOLS.length} tools generated from the schema via introspection. ~250 lines of glue code.
        The server reads the schema, turns each query into a read tool and each mutation into a write tool. 
        Names, descriptions, and parameters come directly from the type definitions. When the schema evolves, tools update automatically.
      </p>

      <h3 style={{ fontSize: 13, color: colors.green, fontWeight: 600, margin: "0 0 12px", textTransform: "uppercase", letterSpacing: 1 }}>
        Read ({reads.length})
      </h3>
      <div style={{ display: "flex", flexDirection: "column", gap: 4, marginBottom: 24 }}>
        {reads.map(t => (
          <div key={t.name} style={{
            display: "flex", justifyContent: "space-between", alignItems: "center",
            padding: "10px 14px", borderRadius: 6, border: `1px solid ${colors.border}`,
            background: colors.surface,
          }}>
            <code style={{ fontSize: 13, color: colors.cyan }}>{t.name}</code>
            <span style={{ fontSize: 12, color: colors.textMuted }}>{t.desc}</span>
          </div>
        ))}
      </div>
      <h3 style={{ fontSize: 13, color: colors.amber, fontWeight: 600, margin: "0 0 12px", textTransform: "uppercase", letterSpacing: 1 }}>
        Write ({writes.length})
      </h3>
      <div style={{ display: "flex", flexDirection: "column", gap: 4, marginBottom: 32 }}>
        {writes.map(t => (
          <div key={t.name} style={{
            display: "flex", justifyContent: "space-between", alignItems: "center",
            padding: "10px 14px", borderRadius: 6, border: `1px solid ${colors.border}`,
            background: colors.surface,
          }}>
            <code style={{ fontSize: 13, color: colors.amber }}>{t.name}</code>
            <span style={{ fontSize: 12, color: colors.textMuted }}>{t.desc}</span>
          </div>
        ))}
      </div>

      <div style={{
        border: `1px solid ${colors.border}`, borderRadius: 12, padding: 24,
        background: colors.surface,
      }}>
        <h3 style={{ fontSize: 15, fontWeight: 600, color: colors.text, margin: "0 0 10px" }}>
          The thin bridge pattern
        </h3>
        <div style={{ fontSize: 13, color: colors.textMuted, lineHeight: 1.7 }}>
          <p style={{ margin: "0 0 10px" }}>
            The MCP server is intentionally minimal. It reads the schema via introspection and exposes each 
            operation as a tool. No hand-written descriptions, no manual parameter mapping, no domain logic in the bridge.
          </p>
          <p style={{ margin: 0 }}>
            When an AI agent struggles with a tool, that's a signal the <strong style={{ color: colors.text }}>schema description</strong> needs 
            improvement, not the bridge. Fix the source of truth and every consumer benefits: docs, IDEs, MCP tools, and direct API callers.
          </p>
        </div>
      </div>
    </div>
  );
}

function AIPage() {
  const [selectedIdx, setSelectedIdx] = useState(null);
  const [displayedOutput, setDisplayedOutput] = useState("");
  const [isTyping, setIsTyping] = useState(false);
  const resultRef = useRef(null);
  const intervalRef = useRef(null);

  const startReplay = useCallback((idx) => {
    if (intervalRef.current) clearInterval(intervalRef.current);
    setSelectedIdx(idx);
    setDisplayedOutput("");
    setIsTyping(true);
    const fullOutput = DEMO_PAIRS[idx].output;
    let charIdx = 0;
    intervalRef.current = setInterval(() => {
      charIdx += 3;
      if (charIdx >= fullOutput.length) {
        clearInterval(intervalRef.current);
        setDisplayedOutput(fullOutput);
        setIsTyping(false);
      } else {
        setDisplayedOutput(fullOutput.substring(0, charIdx));
      }
    }, 8);
  }, []);

  useEffect(() => {
    return () => { if (intervalRef.current) clearInterval(intervalRef.current); };
  }, []);

  useEffect(() => {
    if (displayedOutput && resultRef.current) {
      resultRef.current.scrollIntoView({ behavior: "smooth", block: "nearest" });
    }
  }, [selectedIdx]);

  return (
    <div style={{ maxWidth: 760, margin: "0 auto", padding: "40px 20px" }}>
      <h1 style={{ fontSize: 32, fontWeight: 700, color: colors.text, margin: "0 0 8px", fontFamily: "'DM Serif Display', Georgia, serif" }}>
        AI Preview
      </h1>
      <p style={{ fontSize: 15, color: colors.textMuted, margin: "0 0 8px" }}>
        Pre-recorded responses showing how Claude identifies the correct API operations from natural language prompts, 
        using only the GraphQL schema as context. No custom instructions, no few-shot examples, no tool definitions.
      </p>
      <p style={{ fontSize: 13, color: colors.textDim, margin: "0 0 32px" }}>
        This is a simulated preview, not a live API call. The purpose is to demonstrate that well-annotated schema 
        descriptions are sufficient for a model to select the right operations and structure valid queries. 
        Variable values and placeholder IDs are illustrative.
      </p>

      <div style={{ display: "flex", flexDirection: "column", gap: 6, marginBottom: 32 }}>
        {DEMO_PAIRS.map((pair, i) => (
          <button key={i} onClick={() => startReplay(i)} style={{
            padding: "12px 16px", borderRadius: 8, border: `1px solid ${selectedIdx === i ? colors.accent : colors.border}`,
            background: selectedIdx === i ? colors.accentSoft : colors.surface,
            color: selectedIdx === i ? colors.text : colors.textMuted,
            fontSize: 13, cursor: "pointer", fontFamily: "inherit", textAlign: "left",
            transition: "all 0.2s", lineHeight: 1.5,
          }}>
            <span style={{ color: colors.textDim, marginRight: 8, fontFamily: "monospace" }}>â†’</span>
            {pair.prompt}
          </button>
        ))}
      </div>

      {selectedIdx !== null && (
        <div ref={resultRef}>
          <div style={{
            padding: "12px 16px", borderRadius: "8px 8px 0 0", border: `1px solid ${colors.border}`,
            borderBottom: "none", background: "#252a3a",
            display: "flex", alignItems: "center", gap: 10,
          }}>
            <div style={{ display: "flex", gap: 6 }}>
              <div style={{ width: 10, height: 10, borderRadius: "50%", background: "#ff5f57" }} />
              <div style={{ width: 10, height: 10, borderRadius: "50%", background: "#febc2e" }} />
              <div style={{ width: 10, height: 10, borderRadius: "50%", background: "#28c840" }} />
            </div>
            <span style={{ fontSize: 11, color: "#8890a4", fontFamily: "monospace" }}>
              claude â€” schema-only generation
            </span>
            <div style={{ marginLeft: "auto", display: "flex", gap: 8 }}>
              <Badge color={colors.green} bg={colors.greenSoft}>schema only</Badge>
              <Badge color={colors.cyan} bg={colors.cyanSoft}>no instructions</Badge>
            </div>
          </div>
          <div style={{
            border: `1px solid ${colors.border}`, borderRadius: "0 0 8px 8px",
            background: "#1e2130", padding: 16, minHeight: 120,
          }}>
            <div style={{ marginBottom: 12 }}>
              <span style={{ color: "#6ee7b7", fontFamily: "monospace", fontSize: 13 }}>$ </span>
              <span style={{ color: "#94a3b8", fontFamily: "monospace", fontSize: 13 }}>
                "{DEMO_PAIRS[selectedIdx].prompt}"
              </span>
            </div>
            <pre style={{
              margin: 0, overflow: "auto", fontSize: 13, lineHeight: 1.6,
              color: "#c4cbd8", fontFamily: "'JetBrains Mono', 'Fira Code', monospace",
              maxHeight: 500,
            }}>
              <code>{displayedOutput}</code>
              {isTyping && <span style={{ color: colors.accent, animation: "blink 0.8s infinite" }}>â–Œ</span>}
            </pre>
          </div>
          <style>{`@keyframes blink { 0%, 50% { opacity: 1 } 51%, 100% { opacity: 0 } }`}</style>
        </div>
      )}

      <div style={{
        border: `1px solid ${colors.border}`, borderRadius: 12, padding: 24,
        background: colors.surface, marginTop: 32,
      }}>
        <h3 style={{ fontSize: 15, fontWeight: 600, color: colors.text, margin: "0 0 10px" }}>
          How this works
        </h3>
        <div style={{ fontSize: 13, color: colors.textMuted, lineHeight: 1.7 }}>
          <p style={{ margin: "0 0 10px" }}>
            These responses were generated by giving Claude the GraphQL schema as its only context. No few-shot examples.
            No system prompt explaining Buffer's domain. No MCP tool definitions. Just the type system with its annotations.
          </p>
          <p style={{ margin: "0 0 10px" }}>
            The demo is pre-recorded to show that the model correctly identifies which operations to use and how to 
            structure queries. Variable values and IDs are illustrative. The key takeaway is operation selection, not runtime execution.
          </p>
          <p style={{ margin: 0 }}>
            This is the core thesis: <strong style={{ color: colors.text }}>well-annotated schemas eliminate the need for thick
            adapter layers between APIs and AI agents.</strong> The investment in good descriptions pays dividends across
            every consumption channel: docs, IDEs, and AI agents.
          </p>
        </div>
      </div>
    </div>
  );
}

// â”€â”€â”€ MAIN APP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export default function App() {
  const [page, setPage] = useState("landing");
  const [sidebarOpen, setSidebarOpen] = useState(true);

  const nav = [
    { key: "landing", label: "Overview", icon: "â—ˆ" },
    { key: "quickstart", label: "Quickstart", icon: "â–¸" },
    { key: "errors", label: "Errors", icon: "âš " },
    { key: "workflows", label: "Workflows", icon: "âŸ³" },
    { key: "reference", label: "API Reference", icon: "â¬¡" },
    { key: "mcp", label: "MCP Server", icon: "ðŸ”Œ" },
    { key: "design", label: "AI Design", icon: "â—‡" },
    { key: "ai", label: "AI Preview", icon: "âœ¦" },
  ];

  const renderPage = () => {
    switch (page) {
      case "landing": return <LandingPage onNavigate={setPage} />;
      case "reference": return <APIReferencePage />;
      case "mcp": return <MCPServerPage />;
      case "ai": return <AIPage />;
      default: return <DocsPage docKey={page} />;
    }
  };

  return (
    <div style={{
      display: "flex", minHeight: "100vh", fontFamily: "'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif",
      background: colors.bg, color: colors.text,
    }}>
      {/* Sidebar */}
      <nav style={{
        width: sidebarOpen ? 200 : 0, minHeight: "100vh", borderRight: `1px solid ${colors.border}`,
        background: colors.surface, padding: sidebarOpen ? "20px 10px" : 0, overflow: "hidden",
        transition: "all 0.2s", flexShrink: 0,
      }}>
        <div style={{ display: "flex", alignItems: "center", gap: 8, padding: "0 4px 20px", borderBottom: `1px solid ${colors.border}`, marginBottom: 16 }}>
          <div style={{
            width: 24, height: 24, borderRadius: 5, background: colors.accent,
            display: "flex", alignItems: "center", justifyContent: "center", fontSize: 12, fontWeight: 700, color: "#fff",
          }}>B</div>
          <span style={{ fontSize: 13, fontWeight: 600, color: colors.text }}>DevEx Kit</span>
        </div>
        <div style={{ display: "flex", flexDirection: "column", gap: 2 }}>
          {nav.map(item => (
            <NavItem
              key={item.key}
              label={item.label}
              icon={item.icon}
              active={page === item.key}
              onClick={() => setPage(item.key)}
            />
          ))}
        </div>
        <div style={{ marginTop: "auto", padding: "20px 4px 0", borderTop: `1px solid ${colors.border}`, position: "absolute", bottom: 20, left: 10, right: 10 }}>
          <a href="https://github.com" target="_blank" rel="noopener" style={{
            fontSize: 12, color: colors.textDim, textDecoration: "none",
            display: "flex", alignItems: "center", gap: 6,
          }}>
            â†— View on GitHub
          </a>
        </div>
      </nav>

      {/* Main content */}
      <main style={{ flex: 1, overflowY: "auto", minHeight: "100vh" }}>
        {/* Top bar */}
        <div style={{
          position: "sticky", top: 0, zIndex: 10, display: "flex", alignItems: "center",
          padding: "10px 20px", background: `${colors.bg}f0`, backdropFilter: "blur(12px)",
          boxShadow: "0 1px 0 rgba(0,0,0,0.06)",
        }}>
          <button onClick={() => setSidebarOpen(!sidebarOpen)} style={{
            background: "none", border: "none", color: colors.textMuted, cursor: "pointer",
            fontSize: 16, padding: 4, marginRight: 12,
          }}>
            {sidebarOpen ? "â—" : "â–·"}
          </button>
          <span style={{ fontSize: 12, color: colors.textDim }}>
            {nav.find(n => n.key === page)?.label || ""}
          </span>
          <span style={{
            marginLeft: "auto", fontSize: 11, color: colors.textDim, padding: "3px 8px",
            border: `1px solid ${colors.border}`, borderRadius: 4,
          }}>
            Proof of Concept
          </span>
        </div>
        {renderPage()}
      </main>
    </div>
  );
}
